/* 
   Copyright (C) Guido Schade 2001
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#include "manager_def.h"
#include "transmitter_def.h"
#include "generator_def.h"

#include "datablock_inl.h"

extern Log log;
extern Timer timer;
extern Config config;
extern Task * task;
extern Generator creator;
extern List<MailingList> lists;

static VOID manager_signal(INT sig);
static VOID manager_sigchild(INT sig);
extern MailingList * getList(const SBYTE * listname, const SBYTE * listdomain = NULL);

ULONG  bc_errors, bc_success, bc_spooled;

Manager::Manager()
{
}

Manager::~Manager()
{
}

// take a look at the spool-area
BOOL Manager::start(VOID)
{
  Message * msg = NULL;
  SBYTE * stat = NULL, * mname = NULL, * list = NULL;
  SBYTE * spool_dir = config.getValue(KEY_SERVER_SPOOL_DIR);

  BOOL ok;

  DEBUGGER("Spooler::start()");

  // installing signal handlers .. did i forget something ?
  sigINT  = new SignalHandler(SIGINT, manager_signal);
  sigHUP  = new SignalHandler(SIGHUP, manager_signal);
  sigPIPE = new SignalHandler(SIGPIPE, manager_signal);
  sigUSR1 = new SignalHandler(SIGUSR1, manager_signal);
  sigUSR2 = new SignalHandler(SIGUSR2, manager_signal);
  sigCHLD = new SignalHandler(SIGCHLD, manager_sigchild);
  sigALRM = new SignalHandler(SIGALRM, manager_signal);

  // check if there are messages in the spool area
  if (!(msg = getNext(spool_dir)))
    return(FALSE);

  ASSERT(msg);
  ASSERT(msg->mconf);

  stat = msg->mconf->getValue(KEY_MESG_STAT);
  mname = msg->mconf->getValue(KEY_MESG_NAME);

  ASSERT(stat);
  ASSERT(mname);

  log.add(3,"info: message '%s' will be processed (status: %s)", mname, stat);

  // generate answer/approve broadcast
  if (!strcmp(stat, "received"))
  {
    // check if message has multiple recipients
    if (msg->recipients.getCount() > 1)
    {
      Address * add = NULL;
      Message * tmp = NULL;

      // create multiple single messages only containing one recipient
      for (add = msg->recipients.getFirst(); add; add = msg->recipients.getNext(add))
      {
        if ((tmp = msg->clone(mname, add)))
        {
          tmp->queue("received", Q_INIT);
          tmp->unlock();
          delete tmp;
        }
      }
      msg->queue("splitted", Q_DONE);
      msg->unlock();
      return(TRUE);
    }
    return(process(msg));
  }

  // broadcast to all recipients
  if (!strcmp(stat, "approved"))
  {
    if ((ok = broadcast(msg)) == TRUE)
      msg->queue("sent", Q_DONE);
    else
      msg->queue("failed", Q_DONE);

    msg->unlock();
    return(ok);
  }

  // spooled message or generated by limez
  if (!strcasecmp(stat, "spooled") || !strcasecmp(stat, "created"))
  {
    // prepare transmitter which will send the message
    Transmitter * trans = new Transmitter();
    ASSERT(trans);

    trans->setStart(timer.getUnix());
    trans->setJob(MODE_TRANSMIT);
    trans->setPid(getPid());
    trans->setMsg(msg);

    // if message was spooled and to list
    if ((list = msg->mconf->getValue(KEY_LIST_NAME)))
      trans->setBroadcast(list);

    // sending message
    if (trans->start() == TRUE)
      msg->queue("sent", Q_DONE);
    else
      msg->queue("spooled", Q_AGAIN);

    msg->unlock();
    delete trans;
    return(TRUE);
  }

  log.add(1,"error: message '%s' contained unknown status '%s'", mname, stat);
  return(FALSE);
}

// getting next spoolentry
Message * Manager::getNext(SBYTE * dname)
{
  List<Message>  messages;
  Message * msg = NULL;
  ULONG  dat = 0, init_date, chng_date;
  STRING file;
  STRIDX idx;
  ULONG  time = timer.getUnix();
  ULONG  server_max_queuetime = config.getIntValue(KEY_SERVER_MAX_QUEUETIME);
  ULONG  server_max_queuetries = config.getIntValue(KEY_SERVER_MAX_QUEUETRIES);
  ULONG  server_queue_interval = config.getIntValue(KEY_SERVER_QUEUE_INTERVAL);
  SBYTE  * mesg_trys = NULL, * mesg_name = NULL, * mail_stat = NULL;

  struct dirent * mydirentry = NULL;
  DIR * mydir = NULL;

  DEBUGGER("Spooler::getNext()");
  ASSERT(dname);

  log.add(6,"info: opening dir '%s'", dname);
  if (!(mydir = opendir(dname)))
  {
    log.add(2,"error: opening dir '%s' failed", dname);
    return(NULL);
  }

  // get all files from directory
  while((mydirentry = readdir(mydir)))
  {
    file = mydirentry->d_name;

    idx = file.find(FILE_CONF_EXT);
    if (idx != string::npos)
    {
      file = file.substr(0, idx);
      log.add(6,"info: spool entry '%s' found", file.c_str());

      currMsg = new Message();
      ASSERT(currMsg);
      currMsg->init();

      if (currMsg->unqueue(file) == TRUE)
      {
        ASSERT(currMsg);
        messages.add(currMsg);
      }
      else
        delete currMsg;
    }
  }

  log.add(6,"info: closing dir '%s'", dname);
  if (closedir(mydir) < 0)
  {
    log.add(2,"error: closedir '%s' failed", dname);
    return(NULL);
  }

  // break if no message found
  if (!messages.getCount())
  {
    log.add(5,"info: no messages in queue, nothing to do");
    return(NULL);
  }

  // getting newest message of all
  for (currMsg = messages.getFirst(); currMsg; currMsg = messages.getNext(currMsg))
  {
    init_date = currMsg->mconf->getIntValue(KEY_MESG_INIT_DATE);
    chng_date = currMsg->mconf->getIntValue(KEY_MESG_CHNG_DATE);
    mesg_name = currMsg->mconf->getValue(KEY_MESG_NAME);
    mail_stat = currMsg->mconf->getValue(KEY_MESG_STAT);
    mesg_trys = currMsg->mconf->getValue(KEY_MESG_TRIES);

    if (chng_date >= dat)
    {
      // look if lock-file exists
      if (currMsg->hasLock() == FALSE)
      {
        log.add(5, "info: no lock-file for message '%s'", mesg_name);

        // check if current message is new
        if (!strcmp(mail_stat, "spooled"))
        {
          log.add(4, "info: message '%s' is waiting for next spool", mesg_name);

          // check if next spoolrun is due
          if (time > chng_date + server_queue_interval)
          {
            if ((time > init_date + server_max_queuetime) ||
                (server_max_queuetries < (ULONG) atol(mesg_trys)))
            {
              MailingList * ml = NULL;
              SBYTE * admin = NULL;
              SBYTE * listname = currMsg->mconf->getValue(KEY_LIST_NAME);

              // send mail to either list_admin or server_admin
              if (listname && (ml = getList(listname)))
                admin = ml->mlconfig.getValue(KEY_LIST_ADMIN);
              else
                admin = config.getValue(KEY_SERVER_ADMIN);

              if (admin)
                creator.sendError(currMsg->getRec(), admin);

              // delete message from spoolarea
              currMsg->lock();
              currMsg->queue("failed", Q_DONE);
              currMsg->unlock();
              log.add(2,"warning: message '%s' has been deleted from spool-area", mesg_name);
            }
            else
            {
              log.add(4,"info: message '%s' is ready for next spoolrun", mesg_name);
              dat = chng_date;
              msg = currMsg;
            }
          }
        }
        else
        {
          log.add(4,"info: message '%s' is new", mesg_name);
          dat = chng_date;
          msg = currMsg;
        }
      }
      else
        log.add(5,"info: message '%s' is already locked", mesg_name);
    }
  }

  // no urgent message without lock-file found
  if (!msg)
    return(NULL);
  else
    log.add(5,"info: message '%s' (status: %s) has been selected for this spoolrun",
              msg->mconf->getValue(KEY_MESG_STAT), mesg_name);

  // creating lock-file and return selected message
  messages.del(msg);
  msg->lock();
  msg->mlog.add(5,"lockfile created by process: %s", task->getSPid());
  return(msg);
}

// broadcast message
BOOL Manager::broadcast(Message * msg)
{
  Task * t = NULL;
  MailingList * ml = NULL;
  Transmitter * trans = NULL;
  DataBlock block(TYPE_ADDRESS);
  ULONG ucount = 0, curr = 0, num = 0;
  Address * rec = NULL, * adr = NULL, * snd = NULL;
  SBYTE * list = NULL;
  BOOL  metoo, verbose;
  ULONG maxprocs, start, seconds, numUsers;

  pid_t npid;

  DEBUGGER("Spooler::broadcast()");
  ASSERT(msg);

  rec = msg->getRec();
  snd = msg->getSender();
  list = rec->getUser();

  ASSERT(snd);
  ASSERT(rec);
  ASSERT(list);

  log.add(2,"info: broadcast from '%s@%s' to list '%s' initiated",
            snd->getUser(), snd->getDomain(), list);

  // given list not found
  if (!(ml = getList(list)))
  {
    log.add(2,"warning: listname '%s' unknown, broadcast failed", list);
    return(FALSE);
  }

  // get total number of users subscribed to list
  numUsers = ml->getUserCount();
  bc_errors = bc_success = bc_spooled = 0;

  // generate pre broadcast mail to sender
  if ((verbose = ml->mlconfig.getBoolValue(KEY_LIST_VERBOSE)))
    creator.preBroadcast(list, numUsers, snd);

  maxprocs = ml->mlconfig.getIntValue(KEY_LIST_MAX_SEND_TASKS);
  metoo = ml->mlconfig.getBoolValue(KEY_LIST_ME_TOO);
  start = timer.getUnix();

  // sending mails to all recipients of given list (read users from tmp-file we create)
  while (ml->getAllUsers(&block, ++ucount, MAX_USERS_ONCE, TRUE) == TRUE)
  {
    num = block.getCount();
    log.add(4,"info: found %d (%d x) user of list '%s' for broadcast", num, ucount, list);

    // getting all users from block
    while(block.get(&adr) == TRUE)
    {
      curr ++;

      // check if sender wants to get a copy
      if (metoo == FALSE)
        if (adr->compare(snd) == TRUE)
          continue;

      // check maximum process - count
      while (tasks.getCount() >= maxprocs)
      {
        log.add(3,"info: list '%s', max process limit of %ld reached, sleeping %ld secs",
                  list, maxprocs, BROADCAST_SLEEP_TIME);
        sleep(BROADCAST_SLEEP_TIME);
        continue;
      }

      // waiting some msecs
      usleep(25000);

      // create new transmitter
      trans = new Transmitter();
      ASSERT(trans);
      trans->setJob(MODE_TRANSMIT);
      trans->setStart(timer.getUnix());

      sigCHLD->suspend();
      switch((npid = fork()))
      {
        case(-1):
        {
          log.add(1,"error: critical, fork() failed (%s), waiting some secs", strerror(errno));
          delete adr;
          sleep(60);
          break;
        }

        case(0):
        {
          // task (child) execution and exit
          tasks.add(trans);
          sigCHLD->release();

          npid = getpid();
          log.setPid(npid);
          trans->setPid(npid);
          trans->setBroadcast(list);

          // create new message
          trans->setMsg(msg);

          // setting new recipient
          msg->recipients.clear();
          msg->addRec(adr);

          log.add(2,"info: task with pid %d is sending mail to user '%s@%s' (#%ld)",
                    npid, adr->getUser(), adr->getDomain(), curr);
          exit(!trans->start());
          break;
        }

        default:
        {
          // spooler (parent) stuff
          trans->setPid(npid);
          tasks.add(trans);
          delete adr;
          sigCHLD->release();
          break;
        }
      }
    }
  }

  // waiting for all sending tasks
  while (tasks.getCount() > 0)
  {
    sigCHLD->suspend();
    log.add(4,"info: broadcast to list '%s' finished, waiting for %ld sending process(es)",
              list, tasks.getCount());

    // check all running tasks and kill them if we have to
    for (t = tasks.getFirst(); t; t = tasks.getNext(t))
    {
      if (t->getStart() + MAX_TRANSCEIVER_TIME < timer.getUnix())
      {
        log.add(2,"warning: sending task (%ld) TERM signal, went to old (%ld secs)",
            t->getPid(), timer.getUnix() - t->getStart());
        kill(t->getPid(), SIGTERM);
      }
    }
    sigCHLD->release();
    sleep(30);
  }

  seconds = timer.getUnix() - start;
  log.add(2,"info: successfully sent message to %d/%d users of list '%s' (%ld secs, %3.1f ops)",
      bc_success, numUsers, list, seconds, (FLOAT)((((FLOAT)numUsers)+0.01)/(FLOAT)(seconds+0.01)));

  // generate past broadcast mail to sender if requested
  if (verbose == TRUE)
    creator.pastBroadcast(list, numUsers, bc_success, 0, 0, seconds, msg->getSize(), snd);

  return(TRUE);
}

// processing message (received) -> look at recipients and decide what to do
BOOL Manager::process(Message * msg)
{
  Address * add = NULL, * snd = NULL;
  Message * newmsg = NULL;
  MailingList * ml = NULL;

  RECTYPE res;
  BOOL found;

  DEBUGGER("Manager::process()");

  ASSERT(msg);
  snd = msg->getSender();
  ASSERT(snd);

  if ((add = msg->getRec()))
  {
    found = FALSE;

    switch((res = add->isValidRec()))
    {
      // mail to listprogram or alias
      case(REC_PROG):
      {
        STRING newnam = string(timer.getRDate()) + "-" + task->getSPid() + "-" + getNextId();

        // set new recipient
        Address * nrec = new Address;
        nrec->setUserName(snd->getUser());
        nrec->setDomainName(snd->getDomain());

        // set new sender
        Address * nsnd = new Address;
        nsnd->setUserName(add->getUser());
        nsnd->setDomainName(add->getDomain());

        newmsg = new Message();
        newmsg->init();
        newmsg->setName(newnam);
        newmsg->addRec(nrec);
        newmsg->setSender(nsnd);

        // generate answer-message
        if (newmsg->generateAnswer(msg->getName()) == TRUE)
        {
          // creating lockfile and saving created message
          newmsg->mconf->addValue(KEY_MESG_ORIG, msg->getName());
          newmsg->lock();
          newmsg->save();
          newmsg->queue("created", Q_INIT);
          newmsg->unlock();
        }
        else
          log.add(2,"warning: generate answer failed or quiet requested");

        delete newmsg;
        msg->queue("done", Q_DONE);
        break;
      }

      // approving broadcast to one of our lists
      case(REC_LIST):
      {
        if ((ml = getList(add->getUser())))
        {
          ULONG size = ml->mlconfig.getIntValue(KEY_LIST_MAX_MAILSIZE);

          // check mailsize
          if (msg->getSize() > (ULONG) size)
          {
            // size exceeded, generate message back to sender and maybe to admin
            creator.maxSize(ml->mlconfig.getValue(KEY_LIST_NAME), snd, size,
                            ml->mlconfig.getValue(KEY_LIST_ADMIN));
            msg->queue("rejected", Q_DONE);
            break;
          }

          // check if sender is authorized
          if (ml->isUserAuthorized(snd) == FALSE)
          {
            // user is not authorized to send, create message
            creator.nonMemberBroadcast(ml->mlconfig.getValue(KEY_LIST_NAME),
               ml->mlconfig.getValue(KEY_LIST_SEND), ml->mlconfig.getValue(KEY_LIST_ADMIN), snd);

            msg->queue("rejected", Q_DONE);
          }
          else
            msg->queue("approved", Q_NONE);
        }
        break;
      }

      default:        
      {
        log.add(1,"error: received message contains invalid recipient (%s@%s)",
                  add->getUser(), add->getDomain());
        msg->queue("error", Q_DONE);
        break;
      }
    }
  }

  msg->unlock();
  return (TRUE);
}


// task death (global signal handler function)
static VOID manager_sigchild(INT sig)
{
  INT    status, pid, found = FALSE;
  Task * currTask = NULL, * nextTask = NULL;

  while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
  {
    if (status & 0xff)
      log.add(1,"error: task (%ld) has been killed with signal %d, pretty bad", pid, status & 0xff);
    else
    {
      if (((status >> 8) & 0xff) == FALSE)
      {
        bc_success ++;
        log.add(4,"info: task (%ld) exited (send succeeded)", pid);
      }
      else
      {
        bc_errors ++;
        log.add(4,"info: task (%ld) exited (send failed)", pid);
      }
    }

    currTask = task->tasks.getFirst();
    while(currTask)
    {
      nextTask = task->tasks.getNext(currTask);
      if (pid == currTask->getPid())
      {
        found = TRUE;
        task->tasks.del(currTask);
        delete currTask;
      }
      currTask = nextTask;
    }

    if (found == FALSE)
      log.add(2,"error: task got SIGCHLD from unknown process, pretty bad (pid %ld)", pid);
  }
  return;
}

// global spooler exception handler
static VOID manager_signal(INT sig)
{
  switch(sig)
  {
    case(SIGPIPE):
    {
      log.add(2,"info: manager just got sigpipe ... connection closed");
      break;
    }

    case(SIGINT):
    {
      log.add(1,"info: stop signal received, limez manager task is shutting down");
      exit(0);
      break;
    }

    default:
      log.add(2,"error: manager received unknown signal %d, ignored", sig);
      break;
  }
  return;
}
